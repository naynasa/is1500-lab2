//*******************************************************************************//*	//*	GLD T6963C Arduino drivers//*	//*	(C) by Mark Sproul//*	This code is derived from other works. Credit is given below//*	This is open source like the rest of the arduino source code//*//*	this code is derived from code from Sparkfun//*//*******************************************************************************//*******************************************************************************//*******************************************************************************//*	<MLS> is Mark Sproul msproul -at- skychariot.com//*			http://coewww.rutgers.edu/~msproul///*******************************************************************************//*	Detailed edit history//*******************************************************************************//*	Jan 28,	2010	<MLS> Started on UnivGraphicsLib//*	Feb  8,	2010	<MLS> Ordered Graphic LCD 160x128 Huge sku: LCD-08799 from sparkfun, uses T6963C//*	Feb  8,	2010	<MLS> Started on support for T6963C//*	Feb 12,	2010	<MSS> Received GLCD from Sparkfun//*******************************************************************************#include	<string.h>#include	<stdio.h>#include	<stdlib.h>#if defined(__AVR__)	#include	<avr/pgmspace.h>	#include	<avr/io.h>	#include	<avr/interrupt.h>#endif#if !defined(__AVR_ATmega328P__)	#error this code is currently only for Arduino Uno with atmega328P#endif#include	"HardwareSerial.h"#include	"UnivGraphicsHW_Defs.h"#include	"UnivGraphicsLib.h"#include	"UnivGraphicsHardware.h"	//*	this is the routines that the implementer provides#ifdef _GRAPHICS_HW_GLCD_T6963C_#pragma mark -#pragma mark T6963C private routines//-------------------------------------------------------------------------------------------------// Graphic LCD with Toshiba T6963 controller// Copyright (c) Radoslaw Kwiecien, 2007r// http://en.radzio.dxp.pl/t6963/// Compiler : avr-gcc// Modified By -Gil- to work on Arduino easily : http://domoduino.tumblr.com///-------------------------------------------------------------------------------------------------#include "GDT6963C.h"//-------------------------------------------------------------------------------------------------//// Delay function//	//-------------------------------------------------------------------------------------------------void n_delay(void){volatile unsigned char i;	for(i = 0; i < (F_CPU/1000000); i++)	{		asm("nop");	}}//-------------------------------------------------------------------------------------------------//// Ports intalization////-------------------------------------------------------------------------------------------------void GLCD_InitalizeInterface(void){	//GLCD_DATA_DDR	=	0xFF;	GLCD_DATA_DDR1 |=	GLCD_DATA_MASK1;	GLCD_DATA_DDR2 |=	GLCD_DATA_MASK2;			GLCD_CTRL_DDR	=	((1 << GLCD_WR) | (1 << GLCD_RD) | (1 << GLCD_CE) | (1 << GLCD_CD) | (1 << GLCD_RESET) | (1 << GLCD_FS));	GLCD_CTRL_PORT |=	((1 << GLCD_WR) | (1 << GLCD_RD) | (1 << GLCD_CE) | (1 << GLCD_CD) | (1 << GLCD_RESET) | (1 << GLCD_FS));}//-------------------------------------------------------------------------------------------------//// Reads dispay status////-------------------------------------------------------------------------------------------------unsigned char GLCD_ChceckStatus(void){	uint8_t	tmp;	//GLCD_DATA_DDR	=	0x00;	GLCD_DATA_DDR1	&=	~GLCD_DATA_MASK1;	GLCD_DATA_DDR2	&=	~GLCD_DATA_MASK2;	GLCD_CTRL_PORT	&=	~((1 << GLCD_RD) | (1 << GLCD_CE));	n_delay();	//tmp			=	GLCD_DATA_PIN;	tmp				=	(GLCD_DATA_PIN1 GLCD_DATA_RSHIFT1) | (GLCD_DATA_PIN2 GLCD_DATA_RSHIFT2);	//GLCD_DATA_DDR	=	0xFF;	GLCD_DATA_DDR1	|=	GLCD_DATA_MASK1;	GLCD_DATA_DDR2	|=	GLCD_DATA_MASK2;	GLCD_CTRL_PORT	|=	((1 << GLCD_RD) | (1 << GLCD_CE));	return tmp;}//-------------------------------------------------------------------------------------------------//// Writes instruction ////-------------------------------------------------------------------------------------------------void GLCD_WriteCommand(unsigned char command){	while(!(GLCD_ChceckStatus()&0x03));			// GLCD_DATA_PORT	=	command;	GLCD_DATA_PORT1	&=	~GLCD_DATA_MASK1;	GLCD_DATA_PORT1	|=	(command GLCD_DATA_SHIFT1);	GLCD_DATA_PORT2	&=	~GLCD_DATA_MASK2;	GLCD_DATA_PORT2	|=	(command GLCD_DATA_SHIFT2);	GLCD_CTRL_PORT	&=	~((1 << GLCD_WR) | (1 << GLCD_CE));	n_delay();	GLCD_CTRL_PORT	|=	((1 << GLCD_WR) | (1 << GLCD_CE));}//-------------------------------------------------------------------------------------------------//// Writes data////-------------------------------------------------------------------------------------------------void GLCD_WriteData(unsigned char data){	while(!(GLCD_ChceckStatus()&0x03));	// GLCD_DATA_PORT	=	data;	GLCD_DATA_PORT1	&=	~GLCD_DATA_MASK1;	GLCD_DATA_PORT1	|=	(data GLCD_DATA_SHIFT1);	GLCD_DATA_PORT2	&=	~GLCD_DATA_MASK2;	GLCD_DATA_PORT2	|=	(data GLCD_DATA_SHIFT2);	GLCD_CTRL_PORT	&=	~((1 << GLCD_WR) | (1 << GLCD_CE) | (1 << GLCD_CD));	n_delay();	GLCD_CTRL_PORT	|=	((1 << GLCD_WR) | (1 << GLCD_CE) | (1 << GLCD_CD));}//-------------------------------------------------------------------------------------------------//// Reads data////-------------------------------------------------------------------------------------------------unsigned char GLCD_ReadData(void){uint8_t tmp;	while(!(GLCD_ChceckStatus()&0x03));	//GLCD_DATA_DDR	=	0x00;	GLCD_DATA_DDR1	&=	~GLCD_DATA_MASK1;	GLCD_DATA_DDR2	&=	~GLCD_DATA_MASK2;	GLCD_CTRL_PORT	&=	~((1 << GLCD_RD) | (1 << GLCD_CE) | (1 << GLCD_CD));	n_delay();	//tmp			=	GLCD_DATA_PIN;	tmp				=	(GLCD_DATA_PIN1 GLCD_DATA_RSHIFT1) | (GLCD_DATA_PIN2 GLCD_DATA_RSHIFT2);	GLCD_CTRL_PORT	|=	((1 << GLCD_RD) | (1 << GLCD_CE) | (1 << GLCD_CD));	//GLCD_DATA_DDR	=	0xFF;	GLCD_DATA_DDR1	|=	GLCD_DATA_MASK1;	GLCD_DATA_DDR2	|=	GLCD_DATA_MASK2;	return tmp;}//-------------------------------------------------------------------------------------------------//// Sets address pointer for display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_SetAddressPointer(unsigned int address){	GLCD_WriteData(address & 0xFF);	GLCD_WriteData(address >> 8);	GLCD_WriteCommand(T6963_SET_ADDRESS_POINTER);}//-------------------------------------------------------------------------------------------------//// Clears text area of display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_ClearText(void){int i;	GLCD_SetAddressPointer(GLCD_TEXT_HOME);	for(i = 0; i < GLCD_TEXT_SIZE; i++)	{		GLCD_WriteDisplayData(0);	}}//-------------------------------------------------------------------------------------------------//// Clears characters generator area of display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_ClearCG(void){unsigned int i;	GLCD_SetAddressPointer(GLCD_EXTERNAL_CG_HOME);	for(i = 0; i < 256 * 8; i++)	{		GLCD_WriteDisplayData(0);	}}//-------------------------------------------------------------------------------------------------//// Clears graphics area of display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_ClearGraphic(void){int i;	GLCD_SetAddressPointer(GLCD_GRAPHIC_HOME);	for(i = 0; i < GLCD_GRAPHIC_SIZE; i++)	{		GLCD_WriteDisplayData(0x00);	}}//-------------------------------------------------------------------------------------------------//// Writes a single character (ASCII code) to display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_WriteChar(char charCode){	GLCD_WriteDisplayData(charCode - 32);}//-------------------------------------------------------------------------------------------------//// Writes null-terminated string to display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_WriteString(char * string){	while(*string)	{		GLCD_WriteChar(*string++);	}}//-------------------------------------------------------------------------------------------------//// Writes null-terminated string from program memory to display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_WriteStringPgm(prog_char * string){char ch;	while((ch = pgm_read_byte(string++)))	{		GLCD_WriteChar(ch);	}}//-------------------------------------------------------------------------------------------------//// Sets display coordinates////-------------------------------------------------------------------------------------------------void GLCD_TextGoTo(unsigned char x, unsigned char y){unsigned int address;	address	=	GLCD_TEXT_HOME + x + (GLCD_TEXT_AREA * y);	GLCD_SetAddressPointer(address);}//-------------------------------------------------------------------------------------------------//// Writes single char pattern to character generator area of display RAM memory////-------------------------------------------------------------------------------------------------void GLCD_DefineCharacter(unsigned char charCode, unsigned char * defChar){unsigned int address;unsigned char i; 	address	=	GLCD_EXTERNAL_CG_HOME + (8 * charCode);	GLCD_SetAddressPointer(address);	for(i = 0; i < 8 ; i++)	{		GLCD_WriteDisplayData(*(defChar + i));	}}//-------------------------------------------------------------------------------------------------//// Set (if color==1) or clear (if color==0) pixel on screen////-------------------------------------------------------------------------------------------------void GLCD_SetPixel(unsigned char x, unsigned char y, unsigned char color){unsigned char tmp;unsigned int address;	address	=	GLCD_GRAPHIC_HOME + (x / GLCD_FONT_WIDTH) + (GLCD_GRAPHIC_AREA * y);	GLCD_SetAddressPointer(address);	GLCD_WriteCommand(T6963_DATA_READ_AND_NONVARIABLE);	tmp	=	GLCD_ReadData();	if(color)	{		tmp |=	(1 << (GLCD_FONT_WIDTH - 1 - (x % GLCD_FONT_WIDTH)));	}	else	{		tmp &=	~(1 << (GLCD_FONT_WIDTH - 1 - (x % GLCD_FONT_WIDTH)));	}	GLCD_WriteDisplayData(tmp);}//-------------------------------------------------------------------------------------------------//// Writes display data and increment address pointer////-------------------------------------------------------------------------------------------------void GLCD_WriteDisplayData(unsigned char x){	GLCD_WriteData(x);	GLCD_WriteCommand(T6963_DATA_WRITE_AND_INCREMENT);}//-------------------------------------------------------------------------------------------------//// Sets graphics coordinates////-------------------------------------------------------------------------------------------------void GLCD_GraphicGoTo(unsigned char x, unsigned char y){unsigned int address;	address	=	GLCD_GRAPHIC_HOME + (x / GLCD_FONT_WIDTH) + (GLCD_GRAPHIC_AREA * y);	GLCD_SetAddressPointer(address);}//-------------------------------------------------------------------------------------------------//// Displays bitmap from program memory////-------------------------------------------------------------------------------------------------void GLCD_Bitmap(unsigned char * bitmap, unsigned char x, unsigned char y, unsigned char width, unsigned char height){unsigned char i, j;	for(j = 0; j < height; j++)	{		GLCD_GraphicGoTo(x, y + j);		for(i = 0; i < width/GLCD_FONT_WIDTH; i++)		{			GLCD_WriteDisplayData(pgm_read_byte(bitmap + i + (GLCD_GRAPHIC_AREA * j))); 			}	}}//-------------------------------------------------------------------------------------------------//// Display initalization////-------------------------------------------------------------------------------------------------void GLCD_Initalize(void){	GLCD_InitalizeInterface();	GLCD_CTRL_PORT &=	~(1 << GLCD_RESET);	_delay_ms(1);	GLCD_CTRL_PORT |=	(1 << GLCD_RESET);#if (GLCD_FONT_WIDTH == 8)	GLCD_CTRL_PORT &=	~(1 << GLCD_FS);#endif	GLCD_WriteData(GLCD_GRAPHIC_HOME & 0xFF);	GLCD_WriteData(GLCD_GRAPHIC_HOME >> 8);	GLCD_WriteCommand(T6963_SET_GRAPHIC_HOME_ADDRESS);	GLCD_WriteData(GLCD_GRAPHIC_AREA);	GLCD_WriteData(0x00);	GLCD_WriteCommand(T6963_SET_GRAPHIC_AREA);	GLCD_WriteData(GLCD_TEXT_HOME);	GLCD_WriteData(GLCD_TEXT_HOME >> 8);	GLCD_WriteCommand(T6963_SET_TEXT_HOME_ADDRESS);	GLCD_WriteData(GLCD_TEXT_AREA);	GLCD_WriteData(0x00);	GLCD_WriteCommand(T6963_SET_TEXT_AREA);	GLCD_WriteData(GLCD_OFFSET_REGISTER);	GLCD_WriteData(0x00);	GLCD_WriteCommand(T6963_SET_OFFSET_REGISTER);	GLCD_WriteCommand(T6963_DISPLAY_MODE | T6963_GRAPHIC_DISPLAY_ON | T6963_TEXT_DISPLAY_ON /*| T6963_CURSOR_DISPLAY_ON*/);	GLCD_WriteCommand(T6963_MODE_SET | 0);}#pragma mark -#pragma mark Graphics Hardware Routines//*******************************************************************************//*	returns TRUE if succesfullboolean	GrahicsHW_CheckIfPresent(void){	return(true);}//*******************************************************************************boolean	GrahicsHW_Init(void){#ifdef _DEBUG_VIA_SERIAL_	Serial.println("GrahicsHW_Init");	#if defined(__AVR_ATmega1280__)		Serial.println("__AVR_ATmega1280__");	#endif#endif	GLCD_Initalize();	gWidth	=	kGLD_T6963C_width;	gHeight	=	kGLD_T6963C_height;#ifdef _DEBUG_VIA_SERIAL_	Serial.println("GrahicsHW_Init exit");#endif	return(true);}//*******************************************************************************void	GrahicsHW_EraseScreen(void){	GLCD_ClearGraphic();	GLCD_ClearText();}//*******************************************************************************void	GrahicsHW_Reset(void){}//*******************************************************************************void	GrahicsHW_SetPixel(short xLoc, short yLoc, unsigned char theColorByte){uint8_t	pixelColor;	if ((xLoc >= gWidth) || (yLoc >= gHeight))	{		return;	}	if ((xLoc < 0) || (yLoc < 0))	{		return;	}	pixelColor	=	(theColorByte ? kCOLOR_Black : kCOLOR_White);	GLCD_SetPixel(xLoc, yLoc, pixelColor);}//*******************************************************************************short	GrahicsHW_GetWidth(void){	return(gWidth);}//*******************************************************************************short	GrahicsHW_GetHeight(void){	return(gHeight);}#endif	//	_GRAPHICS_HW_GLD_T6963C_